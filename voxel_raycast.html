<doctype html>
<!-- Copyright 2020, Cem Yuksel, University of Utah -->
<html>
<head>
<title>Voxel Raycast</title>
<!-- <script type="text/javascript" id="includedscript" src="project6.js"></script> -->
<script type="text/javascript" id="webglm" src="webglm.js"></script>
<script type="text/javascript">

const transZmin = 1.001;
const transZmax = 10;
const maxBounceLimit = 16;

const sensitivityX = 5, sensitivityY = 5;
const moveSpeed = 3;
const interactDistance = 5;

var raytraceVS, raytraceFS;

var canvas, gl;
var perspectiveMatrix;	// perspective projection matrix

var environmentTexture;
var bumpMap;

var viewRotY = 0, viewRotX = 0;
var cameraPos = [0, 0, 2], cameraForward = [0, 0, 1], cameraUp = [0, 1, 0];
var cameraRotX = 0;
var primaryRT, secondaryRT;

var renderDistance = 2; // in chunks (considering current chunk as well)

var keyStates = new Array(256).fill(false);
var placeBlock = false;
var destroyBlock = false;

var chunks = {};

var chunkTex;

var lights = [
	{
		position:  [ 0, 0, 1000 ],
		intensity: [ 1, 1, 1 ]
	}
];

class RayTracer
{
	constructor()
	{
		this.bounceLimit = 5;
	}
	init()
	{
		if ( this.prog ) gl.deleteProgram( this.prog );
		
		this.prog = InitShaderProgram(raytraceVS, raytraceFS);
		if (!this.prog)
			return;
		
		function setMaterial( prog, v, mtl )
		{
			gl.uniform3fv( gl.getUniformLocation( prog, v+'.k_d' ), mtl.k_d );
			gl.uniform3fv( gl.getUniformLocation( prog, v+'.k_s' ), mtl.k_s );
			gl.uniform1f ( gl.getUniformLocation( prog, v+'.n'   ), mtl.n   );
		}
		
		gl.useProgram( this.prog );
		gl.uniform1i( gl.getUniformLocation( this.prog, 'bounceLimit' ), this.bounceLimit );
		for ( var i=0; i<lights.length; ++i ) {
			gl.uniform3fv( gl.getUniformLocation( this.prog, 'lights['+i+'].position'  ), lights[i].position  );
			gl.uniform3fv( gl.getUniformLocation( this.prog, 'lights['+i+'].intensity' ), lights[i].intensity );
		}

		gl.uniform1i(gl.getUniformLocation(this.prog, 'environmentMap'), 0);
		gl.uniform1i(gl.getUniformLocation(this.prog, 'bumpMap'), 1);
		gl.uniform1i(gl.getUniformLocation(this.prog, 'visibleChunks'), 2);

		this.updateProj();
		this.updateChunk();
	}
	updateProj()
	{
		if ( ! this.prog ) return;
		gl.useProgram( this.prog );
		var proj = gl.getUniformLocation( this.prog, 'proj' );
		gl.uniformMatrix4fv( proj, false, perspectiveMatrix );
	}
	updateChunk()
	{
		if (!this.prog) return;
		gl.useProgram(this.prog);
		gl.activeTexture(gl.TEXTURE2);
		gl.bindTexture(gl.TEXTURE_3D, chunkTex);
		gl.texImage3D(gl.TEXTURE_3D, 0, gl.R8, 16, 16, 16, 0, gl.RED, gl.UNSIGNED_BYTE, chunks[chunkCoordString(0, 0, 0)]);
	}
	setBounceLimit( bounceLimit )
	{
		this.bounceLimit = bounceLimit;
		if (!this.prog)
			return;
		gl.useProgram(this.prog);
		gl.uniform1i(gl.getUniformLocation(this.prog, 'bounceLimit'), this.bounceLimit);
	}
	draw(trans)
	{
		if (!this.prog)
			return;

		gl.useProgram(this.prog);

		gl.activeTexture(gl.TEXTURE1);
		gl.bindTexture(gl.TEXTURE_2D, bumpMap);

		screenQuad.draw(this.prog, trans);
	}
};

var screenQuad = {
	init( fov, z )
	{
		if ( ! this.vbuf ) this.vbuf = gl.createBuffer();
		const r = canvas.width / canvas.height;
		const ff = Math.PI * fov / 180;
		const tant_2 = Math.tan( ff/2 );
		const y = z * tant_2;
		const x = y * r;
		const rtp = [
			-x, -y, -z,
			 x, -y, -z,
			 x,  y, -z,
			-x, -y, -z,
			 x,  y, -z,
			-x,  y, -z,
		];
		gl.bindBuffer(gl.ARRAY_BUFFER, this.vbuf);
		gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(rtp), gl.STATIC_DRAW);
	},
	draw( prog, trans )
	{
		gl.useProgram( prog );
		gl.uniformMatrix4fv( gl.getUniformLocation( prog, 'c2w' ), false, trans.camToWorld );
		gl.bindBuffer( gl.ARRAY_BUFFER, this.vbuf );
		var p = gl.getAttribLocation ( prog, 'p' );
		gl.vertexAttribPointer( p, 3, gl.FLOAT, false, 0, 0 );
		gl.enableVertexAttribArray( p );
		gl.drawArrays( gl.TRIANGLES, 0, 6 );
	}
};

function InitShaderScripts()
{
	let client1 = new XMLHttpRequest();
	client1.open('GET', '/shaders/voxel_raycast.vs');
	client1.onload = function(){
		raytraceVS = client1.responseText;
		let client2 = new XMLHttpRequest();
		client2.open('GET', '/shaders/voxel_raycast.fs');
		client2.onload = function() {
			raytraceFS = client2.responseText;
			primaryRT.init();
		}
		client2.send();
	}
	client1.send();
}

function InitScene()
{
	// primaryRT.init();
}

function InitEnvironmentMap()
{
	environmentTexture = gl.createTexture();
	
	gl.activeTexture(gl.TEXTURE0);
	gl.bindTexture( gl.TEXTURE_CUBE_MAP, environmentTexture );
	
	const url = 'https://webglfundamentals.org/webgl/resources/images/computer-history-museum/';
	const files = [
	  'pos-x.jpg',
	  'neg-x.jpg',
	  'pos-y.jpg',
	  'neg-y.jpg',
	  'pos-z.jpg',
	  'neg-z.jpg',
	];
	const faces = [
		gl.TEXTURE_CUBE_MAP_POSITIVE_X,
		gl.TEXTURE_CUBE_MAP_NEGATIVE_X,
		gl.TEXTURE_CUBE_MAP_POSITIVE_Y,
		gl.TEXTURE_CUBE_MAP_NEGATIVE_Y,
		gl.TEXTURE_CUBE_MAP_POSITIVE_Z,
		gl.TEXTURE_CUBE_MAP_NEGATIVE_Z,
	];

	var loaded = 0;
	for ( var i=0; i<6; ++i ) {
		gl.texImage2D( faces[i], 0, gl.RGBA, 128, 128, 0, gl.RGBA, gl.UNSIGNED_BYTE, null );
		const img = new Image();
		img.crossOrigin = "anonymous";
		img.face = faces[i];
		img.onload = function() {
			gl.bindTexture( gl.TEXTURE_CUBE_MAP, environmentTexture );
			gl.texImage2D( this.face, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, this );
			loaded++;
			if ( loaded == 6 ) {
				gl.generateMipmap(gl.TEXTURE_CUBE_MAP);
				DrawScene();
			}
		};
		img.src = url + files[i];
	}
	gl.texParameteri( gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_LINEAR );
}

function InitBumpMaps()
{
	bumpMap = gl.createTexture();
	gl.bindTexture(gl.TEXTURE_2D, bumpMap);
	gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_LINEAR);
	gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
	gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT);
	gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT);

	img = new Image();
	img.src = 'images/bumpmap.png';
	img.onload = function() {
		gl.activeTexture(gl.TEXTURE1);
		gl.bindTexture(gl.TEXTURE_2D, bumpMap);
		gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGB, gl.RGB, gl.UNSIGNED_BYTE, this);
		gl.generateMipmap(gl.TEXTURE_2D);
	};

	// console.log(img)
}

// index in a chunk
function chunkInd(x, y, z) {
	return x + y * 16 + z * 16 * 16;
}

function chunkCoordString(x, y, z) {
	return x.toString() + ":" + y.toString() + ":" + z.toString();
}

// function chunkCoordString(v) {
	// return chunkCoordString(v[0], v[1], v[2]);
// }

function InitWorld()
{
	gl.activeTexture(gl.TEXTURE2);
	chunkTex = gl.createTexture();
	gl.bindTexture(gl.TEXTURE_3D, chunkTex);
	gl.texParameteri(gl.TEXTURE_3D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
	gl.texParameteri(gl.TEXTURE_3D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);



	let chunkData = new Uint8Array(16 * 16 * 16).fill(0);
	chunkData[chunkInd(0, 0, 0)] = 1;
	chunkData[chunkInd(0, 1, 0)] = 1;
	chunkData[chunkInd(2, 2, 2)] = 2;
	chunks[chunkCoordString(0, 0, 0)] = chunkData;
}

// Called once to initialize
function InitWebGL()
{
	// Initialize the WebGL canvas
	canvas = document.getElementById("canvas");
	canvas.oncontextmenu = function() {return false;};
	gl = canvas.getContext("webgl2", {antialias: false, depth: true});	// Initialize the GL context
	if (!gl) {
		alert("Unable to initialize WebGL. Your browser or machine may not support it.");
		return;
	}
	
	// Initialize settings
	gl.clearColor(0,0,0,0);
	gl.enable(gl.DEPTH_TEST);
	
	InitShaderScripts();

	InitEnvironmentMap();

	InitBumpMaps();

	InitWorld();

	primaryRT = new RayTracer;

	UpdateCanvasSize();
	InitScene();
}

// Called every time the window size is changed.
function UpdateCanvasSize()
{
	canvas.style.width  = "100%";
	canvas.style.height = "100%";
	const pixelRatio = window.devicePixelRatio || 1;
	canvas.width  = pixelRatio * canvas.clientWidth;
	canvas.height = pixelRatio * canvas.clientHeight;
	const width  = (canvas.width  / pixelRatio);
	const height = (canvas.height / pixelRatio);
	canvas.style.width  = width  + 'px';
	canvas.style.height = height + 'px';
	gl.viewport( 0, 0, canvas.width, canvas.height );
	UpdateProjectionMatrix();
}

function UpdateProjectionMatrix()
{
	const fov = 60;
	var r = canvas.width / canvas.height;
	var n = 0.1;
	const min_n = 0.001;
	if ( n < min_n ) n = min_n;
	var f = transZmax*100;
	var ff = Math.PI * fov / 180;
	var tant_2 = Math.tan( ff/2 );
	var s = 1 / tant_2;
	perspectiveMatrix = [
		s/r, 0, 0, 0,
		0, s, 0, 0,
		0, 0, -(n+f)/(f-n), -1,
		0, 0, -2*n*f/(f-n), 0
	];
	
	screenQuad.init(fov,(n+f)/2);
	primaryRT.updateProj();
}

function getCubeId(X, Y, Z) {
	let chunkX = Math.floor(X / 16);
	let chunkY = Math.floor(Y / 16);
	let chunkZ = Math.floor(Z / 16);
	chunkCoordStr = chunkCoordString(chunkX, chunkY, chunkZ);

	if (chunkCoordStr in chunks) {
		return chunks[chunkCoordStr][chunkInd(X - (chunkX * 16), Y - (chunkY * 16), Z - (chunkZ * 16))];
	}
	// Generate new chunk
	let chunkData = new Uint8Array(16 * 16 * 16).fill(0);
	chunks[chunkCoordStr] = chunkData;
	return 0;
}

function putCubeID(X, Y, Z, id) {
	let chunkX = Math.floor(X / 16);
	let chunkY = Math.floor(Y / 16);
	let chunkZ = Math.floor(Z / 16);
	chunkCoordStr = chunkCoordString(chunkX, chunkY, chunkZ);
	
	if (chunkCoordStr in chunks) {
		chunks[chunkCoordStr][chunkInd(X - (chunkX * 16), Y - (chunkY * 16), Z - (chunkZ * 16))] = id;
		return;
	}
	// Generate new chunk
	let chunkData = new Uint8Array(16 * 16 * 16).fill(0);
	chunkData[chunkInd(X - (chunkX * 16), Y - (chunkY * 16), Z - (chunkZ * 16))] = id;
	chunks[chunkCoordStr] = chunkData;
}

function getCurCubeLookingAt() {
	let lookDir = vecScale(cameraForward, -1);
	
	let X = Math.floor(cameraPos[0]);
    let Y = Math.floor(cameraPos[1]);
    let Z = Math.floor(cameraPos[2]);

    let stepX = Math.sign(lookDir[0]);
    let stepY = Math.sign(lookDir[1]);
    let stepZ = Math.sign(lookDir[2]);

    let tDeltaX = Math.abs(1.0 / lookDir[0]);
    let tDeltaY = Math.abs(1.0 / lookDir[1]);
    let tDeltaZ = Math.abs(1.0 / lookDir[2]);

    let tMaxX = tDeltaX * (stepX > 0 ? (1.0 - (cameraPos[0] - X)) : (cameraPos[0] - X));
    let tMaxY = tDeltaY * (stepY > 0 ? (1.0 - (cameraPos[1] - Y)) : (cameraPos[1] - Y));
    let tMaxZ = tDeltaZ * (stepZ > 0 ? (1.0 - (cameraPos[2] - Z)) : (cameraPos[2] - Z));

	let oldX, oldY, oldZ;
    
	while (Math.min(tMaxX, tMaxY, tMaxZ) <= interactDistance) {
		oldX = X;
		oldY = Y;
		oldZ = Z;

        if(tMaxX < tMaxY) {
            if(tMaxX < tMaxZ) {
                X = X + stepX;
                tMaxX = tMaxX + tDeltaX;
            } else {
                Z = Z + stepZ;
                tMaxZ = tMaxZ + tDeltaZ;
            }
        } else {
            if(tMaxY < tMaxZ) {
                Y = Y + stepY;
                tMaxY = tMaxY + tDeltaY;
            } else {
                Z = Z + stepZ;
                tMaxZ = tMaxZ + tDeltaZ;
            }
        }

        if (getCubeId(X, Y, Z) != 0)
			return [[oldX, oldY, oldZ], [X, Y, Z]];
    }
	return null;
}


function UpdateScene(deltaTime)
{
	let moveDir = [0, 0, 0]
	forward = vecNormalize([cameraForward[0], 0, cameraForward[2]])
	if (keyStates[87]) // W
			moveDir = vecAdd(moveDir, vecScale(forward, -1));
	if (keyStates[83]) // S
			moveDir = vecAdd(moveDir, vecScale(forward, 1));
	if (keyStates[65]) // A
			moveDir = vecAdd(moveDir, vecScale(vecCross(cameraUp, cameraForward), -1));
	if (keyStates[68]) // D
			moveDir = vecAdd(moveDir, vecScale(vecCross(cameraUp, cameraForward), 1));
	if (keyStates[16]) // Shift
			moveDir = vecAdd(moveDir, vecScale([0, 1, 0], -1));
	if (keyStates[32]) // Space
			moveDir = vecAdd(moveDir, vecScale([0, 1, 0], 1));
	
	if (moveDir[0] != 0 || moveDir[1] != 0 || moveDir[2] != 0)
		cameraPos = vecAdd(cameraPos, vecScale(vecNormalize(moveDir), moveSpeed * deltaTime));

	let ret = getCurCubeLookingAt();
	// if (ret != null)
		// console.log(ret[0].toString() + " " + ret[1].toString());
	if (destroyBlock && ret != null) {
		destroyPos = ret[1];
		console.log(destroyPos);
		putCubeID(destroyPos[0], destroyPos[1], destroyPos[2], 0);
		primaryRT.updateChunk();
		destroyBlock = false;
	}
	destroyBlock = false;
	if (placeBlock && ret != null) {
		placePos = ret[0];
		console.log(placePos);
		putCubeID(placePos[0], placePos[1], placePos[2], 1);
		primaryRT.updateChunk();
	}
	placeBlock = false;
}

// This is the main function that handled WebGL drawing
function DrawScene()
{
	gl.flush();
	
	var trans = lookAt(cameraPos, cameraForward, cameraUp);
	var mvp = matMul(perspectiveMatrix, trans.worldToCam);

	// Clear the screen and the depth buffer.
	gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
	
	primaryRT.draw(trans);
}

// This is a helper function for compiling the given vertex and fragment shader script ids into a program.
function InitShaderProgramFromScripts( vs, fs )
{
	return InitShaderProgram( document.getElementById(vs).text, document.getElementById(fs).text );	
}

// This is a helper function for compiling the given vertex and fragment shader source code into a program.
function InitShaderProgram( vsSource, fsSource )
{
	const vs = CompileShader( gl.VERTEX_SHADER,   vsSource );
	const fs = CompileShader( gl.FRAGMENT_SHADER, fsSource );

	if ( ! vs || ! fs ) return null;
	
	const prog = gl.createProgram();
	gl.attachShader(prog, vs);
	gl.attachShader(prog, fs);
	gl.linkProgram(prog);

	if (!gl.getProgramParameter(prog, gl.LINK_STATUS)) {
		alert('Unable to initialize the shader program: ' + gl.getProgramInfoLog(prog));
		return null;
	}
	return prog;
}

// This is a helper function for compiling a shader, called by InitShaderProgram().
function CompileShader( type, source )
{
	const shader = gl.createShader(type);
	gl.shaderSource(shader, source);
	gl.compileShader(shader);
	if (!gl.getShaderParameter( shader, gl.COMPILE_STATUS) ) {
		alert('An error occurred compiling shader:\n' + gl.getShaderInfoLog(shader));
		gl.deleteShader(shader);
		return null;
	}
	return shader;
}

async function RunRayTracer()
{
	lastTime = Date.now() / 1000.0;
	while (true) {
		await new Promise(r => setTimeout(r, 20));
		curTime = Date.now() / 1000.0;
		deltaTime = curTime - lastTime;
		lastTime = curTime;

		UpdateScene(deltaTime);

		DrawScene();
	}
}

window.onload = function() {
	InitWebGL();
	canvas.zoom = function( s ) {
		transZ *= s/canvas.height + 1;
		if ( transZ < transZmin ) transZ = transZmin;
		if ( transZ > transZmax ) transZ = transZmax;
		UpdateProjectionMatrix();
	}
	canvas.onwheel = function() { canvas.zoom(0.3*event.deltaY); }
	canvas.onmousedown = function() {
		var cx = event.clientX;
		var cy = event.clientY;
		canvas.onmousemove = function() {
			viewRotY += (cx - event.clientX) / canvas.width * sensitivityX;
			viewRotX += (cy - event.clientY) / canvas.height * sensitivityY;
			cx = event.clientX;
			cy = event.clientY;

			const eps = 0.01;
			if (viewRotX < -Math.PI / 2 + eps)
				viewRotX = -Math.PI / 2 + eps;
			if (viewRotX > Math.PI/2 - eps)
				viewRotX = Math.PI / 2 - eps;

			let cameraForwardAux = matVecMul(rotX(viewRotX), [0, 0, 1, 1]);
			cameraForward = matVecMul(rotY(viewRotY), cameraForwardAux);
			cameraUp = matVecMul(rotX(viewRotX), [0, 1, 0, 1]);
			cameraUp = matVecMul(rotY(viewRotY), cameraUp);
		}
	}
	canvas.oncontextmenu = function () {
		event.preventDefault();
		placeBlock = true;
	}
	canvas.onmouseup = canvas.onmouseleave = function() {
		canvas.onmousemove = null;
	}
	function keyDownListener(e) {
		keyStates[e.keyCode] = true;
		if (e.keyCode == 20) // Caps-Lock
			destroyBlock = true;
		// case 115:	// F4
		// 	document.getElementById('shader_fs').remove();
		// 	var head = document.getElementsByTagName('head')[0];
		// 	var script = document.createElement('script');
		// 	script.src= 'shader.fs';
		// 	script.id = 'shader_fs';
		// 	script.onload = function() {
		// 		primaryRT.init();
		// 		secondaryRT.init();
		// 		DrawScene();
		// 	}
		// 	head.appendChild(script);
		// 	console.log('New script loaded.');
		// 	break;
		// }
	}
	document.addEventListener("keydown", keyDownListener, false);
	function keyUpListener(e) {
		keyStates[e.keyCode] = false;
	}
	document.addEventListener("keyup", keyUpListener, false);

	DrawScene();
	RunRayTracer();
};

function WindowResize()
{
	UpdateCanvasSize();
	DrawScene();
}

function UseEnvironmentMap( param )
{
	gl.bindTexture( gl.TEXTURE_CUBE_MAP, param.checked ? environmentTexture : null );
	DrawScene();
}

function IncBounceLimit( inc )
{
	var b = parseInt(document.getElementById('bounces-value').innerText);
	b += inc;
	if ( b < 0 ) b = 0;
	if ( b > maxBounceLimit ) b = maxBounceLimit;
	SetBounceLimit( b );
	document.getElementById('bounces-range').value = b;
}

function SetBounceLimit( b )
{
	document.getElementById('bounces-value').innerText = b;
	primaryRT.setBounceLimit( b );
	secondaryRT.setBounceLimit( b );
	UpdateProjectionMatrix();
	DrawScene();
}

function IncCount( inc )
{
	var c = parseInt(document.getElementById('count-value').innerText);
	c += inc;
	if ( c < 1 ) c = 1;
	if ( c > 100 ) c = 100;
	SetCount( c );
	document.getElementById('count-range').value = c;
	NewScene();
}

function SetCount( c )
{
	document.getElementById('count-value').innerText = c;
	sphereCount = c;
}

function NewScene()
{
	InitScene();
	primaryRT.init();
	secondaryRT.init();
	DrawScene();
}

function ShowControls()
{
	var c = document.getElementById('controls');
	c.style.display = c.style.display == 'none' ? '' : 'none';
}

///////////////////////////////////////////////////////////////////////////////////
</script>

<style>
html {
	color: white;
	background-color: black;
	font-family: Arial;
	overflow: hidden;
}
body {
	padding: 0;
	margin: 0;
}
input[type=checkbox], forwardlabel {
	cursor: hand;
}
input[type=range] {
	width: 100%;
}
canvas {
	display: block;
	position: absolute;
	top:  0;
	left: 0;
	width:  100%;
	height: 100%;
}
#canvas-div {
	position: relative;
	width: 100%;
	height: 100%;
}
#controls-div {
	background-color: rgba(0,0,0,0.5);
	position: absolute;
	right: 1em;
	top: 1em;
	width: 18em;
}
#controls {
	padding: 1em;
}
.control {
	padding: 0.2em;
	clear: both;
}
.val {
	float: right;
	text-align: right;
}
.value {
	margin-right: 0.5em;
}
.btn {
	width: 100%;
}
#buttons {
	position: absolute;
	right: 0;
	top: 0;
}
#buttons input[type=button] {
	background-color: rgba(80,80,80,0.5);
	color: #aaa;
	font-size: 70%;
	outline: none;
}

#canvas-div {
  position: relative;
}

#canvas {
  display: block;
  background: lightgrey; /* For visibility */
}

#el {
  position: absolute;
  top: 50%;
  left: 50%;
  width: 0;
  height: 0;
  transform: translate(-50%, -50%);
}

#el::after, #el::before {
  content: "";
  background: black;
  position: absolute;
}

#el::after {
  width: 2px; /* Thickness of the vertical line */
  height: 20px; /* Length of the vertical line */
  top: -10px; /* Center vertically */
  left: -1px; /* Center horizontally */
}

#el::before {
  width: 20px; /* Length of the horizontal line */
  height: 2px; /* Thickness of the horizontal line */
  top: -1px; /* Center vertically */
  left: -10px; /* Center horizontally */
}
</style>

</head>
<body onresize="WindowResize()">
<div id="canvas-div">
	<canvas id="canvas"></canvas>
	<div id="el"></div>
</div><div id="controls-div">
<div id="buttons"><input type="button" value="V" onclick="ShowControls()"/></div>
<div id="controls">
<div class="control-group">
<div class="control"><input id="raster" name="method" type="radio" onchange="DrawScene()" /><label for="raster"> Rasterization</label><br/></div>
<div class="control"><input id="raytrace" name="method" type="radio" onchange="DrawScene()" checked /><label for="raytrace"> Ray Tracing</label><br/></div>
<div class="control"><input id="secondary" name="method" type="radio" onchange="DrawScene()" /><label for="secondary"> Rasterization + Ray Tracing</label><br/></div>
<div class="control"><hr/></div>
<div class="control"><input id="envmap" name="envmap" type="checkbox" onchange="UseEnvironmentMap(this)" checked /><label for="envmap"> Environment Map</label></div>
<div class="control"><span id="bounces-label">Bounce Limit:</span><span class="val"><span class="value" id="bounces-value">5</span><input type="button" value="+" onclick="IncBounceLimit(1)"><input type="button" value="&ndash;" onclick="IncBounceLimit(-1)"></span><input id="bounces-range" type="range" min="0" max="16" value="5" oninput="SetBounceLimit(this.value)"/></div>
<div class="control"><span id="count-label">Sphere Count:</span><span class="val"><span class="value" id="count-value">10</span><input type="button" value="+" onclick="IncCount(1)"><input type="button" value="&ndash;" onclick="IncCount(-1)"></span><input id="count-range" type="range" min="1" max="100" value="10" oninput="SetCount(this.value)" onchange="NewScene()"/></div>
<div class="control"><input type="button" class="btn" value="New Random Scene" onclick="NewScene()"></div>
</div>
</div>
</div>
</div>
</body>
</html>